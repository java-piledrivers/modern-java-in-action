## 1.6 함수형 프로그래밍에서 가져온 다른 유용한 아이디어 

1.1~1.5 장을 통해 함수형 프로그램의 두 아이디어를 살펴보았다.

- 메서드와 람다를 일급값으로 사용하는 것
- 가변 공유 상태가 없는 병렬 실행을 이용해서 효율적이고 안전하게 함수나 메서드를 호출할 수 있다는 것

Stream API는 이 두 가지 아이디어를 모두 사용한다.



일반적인 함수형 언어도 프로그램을 돕는 여러 장치를 제공한다 -- 일례로 명시적으로 서술형의 데이터 형식을 이용해 null을 회피하는 기법이 있다.



자바8에서는 NullPointer 예외를 피할 수 있도록 도와주는 `Optional<T>` 클래스를 제공한다.

`Optional<T>`는 값을 갖거나 갖지 않을 수 있는 컨테이너 객체이며, 값이 없는 상황을 어떻게 처리할지 명시적으로 구현하는 메서드를 포함하고 있어 NullPointer 예외를 피할 수 있다.



`구조적 패턴 매칭 기법`도 있다. 패턴 매칭은 수학에서 다음 예제 처럼 사용한다.

````python
f(0) = 1
f(n) = n*f(n-1)
````

자바에서는 `if-then-else`	를 사용했을 것이다. 또한 다형성, 메서드 오버라이딩을 통해 비교문을 만들 수 있다.

하지만 다른 언어에서 패턴 매칭으로 더 정확한 비교를 할 수 있다는 것을 증명했으며, 우리는 기능 구현보다는 언어 설계를 논하고 있음을 기억하자.

아쉽게도 자바8은 아직 완벽히 패턴 매칭을 지원하고 있지 않아, 스칼라 프로그래밍 언어로 패턴 매칭 하는 방법을 살펴본다.

아래는 트리로 구성된 수식을 단순화 하는 프로그램이다.

````scala
def simplifyExpression(expr: Expr): Expr = expr match {
  case BinOp("+", e, Number(0)) => e // 0 추가
  case BinOp("-", e, Number(0)) => e // 0 빼기
  case BinOp("*", e, Number(1)) => e // 1 곱하기
  case BinOp("/", e, Number(1)) => e // 1 나누기
  case _ => expr // 표현식을 단순화 할 수 없음
}
````

스칼라의 expr match는 자바의 switch(expr)과 같은 기능을 수행한다.

패턴 매칭이 switch를 확장한 것으로 데이터 형식 분류와 분석을 한 번에 수행할 수 있다는 정도로만 생각하자.

왜 자바의 switch문에는 문자열과 기본값만 이용할 수 있는 걸까?

함수형 언어는 보통 패턴 매칭을 포함한 다양한 데이터 형식을 switch에 사용할 수 있다(스칼라에서는 match를 활용).

일반적으로 객체지향 설계에서 클래스 패밀리를 방문할 때 `방문자 패턴(visitor pattern)`을 이용해서 각 객체를 방문한 다음에 원하는 작업을 수행한다. 

> <u>**Visitor pattern, 방문자 패턴**</u>
>
> 실제 로직을 가지고 있는 객체(Visitor)가 로직을 적용할 객체(Element)를 방문하면서 실행하는 패턴이다.</br>
> 즉, 로직과 구조를 분리하는 패턴이라고 볼 수 있다.</br> 
> 로직과 구조가 분리되면 구조를 수정하지 않고도 새로운 동작을 기존 객체 구조에 추가할 수 있다.
>
> https://thecodinglog.github.io/design/2019/10/29/visitor-pattern.html 참고



패턴 매칭을 이용하면 "Brakes 클래스는 Car클래스를 구성하는 클래스 중 하나입니다. Brakes를 어떻게 처리해야 할지 설정하지 않았습니다" 와 같은 에러를 검출할 수 있다.

