# 어디에, 어떻게 람다를 사용할까?

결론적으로는 함수형 인터페이스라는 문맥에서 람다 표현식을 사용할 수 있다.


## 함수형 인터페이스
**하나의 추상 메서드를 지정하는 인터페이스**이다.
```java
public interface Predicate<T> {
    boolean test(T t);
}

public interface Comparator<T> { //java.util.Comparator
    int compare(T o1, T o2);
}

public interface Runnable { //java.lang.Runnable
    void run();
}
```

참고로 인터페이스의 경우 디폴트 메서드(인터페이스의 메서드를 구현하지 않은 클래스를 고려해서 기본 구현을 제공하는 바디를 포함하는 메서드)를 포함할 수 있는데, 많은 디폴트 메서드가 있더라도 **추상 메서드가 오직 하나면 함수형 인터페이스**다.
```java
public interface Adder { //함수형 인터페이스
    int add(int a, int b);
}

public interface SmartAdder extends Adder { //두 추상 메서드를 포함하므로 함수형 인터페이스 X
    int add(double a, double b);
}

public interface Nothing { //추상 메서드가 없으므로 함수형 인터페이스 X
}
```


## 함수 디스크립터
함수형 인터페이스의 추상 메서드 시그니처(메서드 구조를 정의한 것)는 람다 표현식의 시그니처를 가리킨다. 함수 디스크립터는 **람다 표현식의 시그니처를 서술하는 메서드**를 의미한다.

예를 들어 Runnable 인터페이스의 유일한 추상 메서드인 `run()`은 인수와 반환값이 없으므로 해당 인터페이스는 인수와 반환값이 없는 시그니처로 생각할 수 있다.
```java
() -> void //파라미터 리스트가 없으며 void를 반환하는 함수를 의미
(Apple, Apple) -> int //두 개의 Apple을 인수로 받아 int를 반환하는 함수를 의미
```

람다 표현식의 형식 검사 원리에 대해서는 3.5절에서 자세하게 설명하므로 현재는 람다 표현식은 변수에 할당하거나 함수형 인터페이스를 인수로 받는 메서드로 전달할 수 있으며, 함수형 인터페이스의 추상 메서드와 같은 시그니처를 갖는다는 사실을 기억해 두자.

또한 '왜 함수형 인터페이스를 인수로 받는 메서드에만 람다 표현식을 사용할 수 있을까?'라는 의문이 생길 수 있다.
그 이유는 아래와 같다.
- 언어 설계자들은 자바에 함수 형식(람다 표현식을 표현하는 데 사용한 시그니처와 같은 특별한 표기법)을 추가하는 방법도 대안으로 고려했으나, 언어를 더 복잡하게 만들지 않는 현재 방법을 선택
- 대부분의 자바 프로그래머가 이벤트 처리 인터페이스와 같이 하나의 추상 메서드를 갖는 인터페이스에 이미 익숙하다는 점도 고려
