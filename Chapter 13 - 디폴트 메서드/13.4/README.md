# 해석 규칙

## 알아야 할 세 가지 해결 규칙

다른 클래스나 인터페이스로부터 같은 시그니처를 갖는 메서드를 상속받을 때는 세 가지 규칙을 따라야 한다.

1. 클래스가 항상 이긴다. 클래스나 슈퍼클래스에서 정의한 메서드가 디폴트 메서드보다 우선권을 갖는다.
  
2. 1번 규칙 이외의 상황에서는 서브인터페이스가 이긴다. 상속관계를 갖는 인터페이스에서 같은 시그니처를 갖는 메서드를 정의할 때는 서브인터페이스가 이긴다. 즉, B가 A를 상속받는다면 B가 A를 이긴다.
  
3. 여전히 디폴트 메서드의 우선순위가 결정되지 않았다면 여러 인터페이스를 상속받는 클래스가 명시적으로 디폴트 메서드를 오버라이드하고 호출해야 한다.
  

## 디폴트 메서드를 제공하는 서브인터페이스가 이긴다

<img width="596" alt="image" src="https://github.com/java-piledrivers/modern-java-in-action/assets/77332981/31d649c3-186d-4406-9102-8506ad55b30a">

B와 A는 hello라는 디폴트 메서드를 정의하고, B는 A를 상속받는 상황에서 B와 A를 구현하는 클래스 C가 등장한다고 가정해보자.
앞서 보았던 2번 규칙에 따르면 서브인터페이스가 이기는 상황이기 때문에, 컴파일러는 B의 hello를 선택한다.

## 충돌 그리고 명시적인 문제 해결

인터페이스 간 상속관계가 없는 경우를 가정해보았을 때, 2번 규칙을 적용할 수 없게 된다. 이는 A와 B의 hello 메서드를 구별할 기준이 없음을 의미하므로, 자바 컴파일러는 어떤 메서드를 호출해야 할지 알 수 없어 에러를 발생시킨다.

**충돌 해결**

클래스와 메서드 관계로 디폴트 메서드를 선택할 수 없는 상황에서는 선택할 수 있는 방법이 없다. 이 문제를 해결하기 위해 메서드를 오버라이드한 다음에 호출하려는 메서드를 명시적으로 선택해야 한다.

## 다이아몬드 문제

<img width="591" alt="image" src="https://github.com/java-piledrivers/modern-java-in-action/assets/77332981/b279967b-dfc7-4d62-8316-bf207a57be2a">

다이어그램의 모양이 다이아몬드를 닮았으므로 다이아몬드 문제라고 부른다.

C는 A를 상속받으므로 C의 추상 메서드가 A의 디폴트 메서드보다 우선권을 갖는다. 이때 B와 C중 어떤 메서드를 호출해야 할지 알 수 없어 컴파일 에러가 발생하게 된다. 따라서 클래스 D가 어떤 메서드를 사용할지 명시적으로 선택해서 에러를 해결해야 한다.

이러한 문제를 마주하지 않기 위해 앞서 언급한 세 가지 규칙을 적용하면 충돌 문제를 해결할 수 있다.
